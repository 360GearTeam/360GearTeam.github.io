---
layout: post
title: "Spectre漏洞分析"
---

**Author: Al3x@GearTeam**

![][1]

<!-- more -->

# 背景

前段时间，`Spectre`和`Meltdown`漏洞爆发，引发广泛关注。这两个漏洞针对处理器设计中存在的缺陷，通过执行程序正常流程中不会执行到的指令来影响CPU缓存，随后结合侧信道攻击技术泄漏程序信息。`Spectre`漏洞涉及 **CVE-2017-5753**（Variant 1：边界检查绕过）和**CVE-2017-5715**(Variant 2：分支目标注入）。`Meltdown`漏洞则利用**CVE-2017-5754**（Variant3：流氓数据加载）。漏洞利用的处理器的缺陷涉及乱序执行和推测执行。`Meltdown`漏洞主要影响**Intel**处理器，而`Spectre`漏洞则影响几乎所有主流处理器。本文只关注`Spectre`漏洞的分析。个人能力有限，文章有什么不足 之处还请各位大牛多多指点。

# 高速缓存

现代处理器的处理速度已远远超过内存的访问速度，内存速度的缓慢将会影响处理器的执行效率。于是引入了高速缓存用于解决这一问题。下图是当前计算机系统中存储器的层次结构：

![][2]

从下往上，越靠上，就越接近处理器，并且存储大小越小，但是相应的读取速度也越快。当数据存储在寄存器中时，处理器访问它所消耗的时间几乎可以忽略不计。当数据存储在高速缓存（L1-L3 Cache）中时，则要消耗4～75个时钟周期。如果是在内存中，访问它则要消耗上百个的时钟周期。再往下的结构，速度会更慢，但本文并没有涉及，所以不再讨论。对于寄存器，由于其容量小、数量也比较少，而且大多数寄存器在程序中都有自己独特的作用，故不再讨论。

高速缓存的作用是临时存储现在或随后处理器运行将会用到的内存数据。这样做可以提高存取速度主要基于程序的局部性：程序总是倾向于访问相同的数据集合，或者倾向于访问临近的数据集合。因此在程序访问某一内存地址时，将一块内存加载入缓存，在接下来的一段时间内，程序很有可能会继续访问到其中的内容，因为缓存的速度较快，所以可以节省很多时间，提高程序运行速度。其实内存速度也可以做的很快，但是成本太高了，所以还是缓存更适用：）

现代`CPU`的数据读写大多数时间都在缓存中完成。在`CPU`发出内存访问请求时，会先检测请求数据是否存在于缓存中，如果存在，则直接返回该数据。如果不存在，则先要把内存中的相应数据载入缓存，然后将其返回给`CPU`。

![][3]

上图是`Intel Core i5-3470`的缓存架构。可以看出该处理器有4个核，每一个核拥有64KB的一级缓存：可以再细分为32KB的数据缓存和32KB的指令缓存。然后是256KB的二级缓存。最后所有核共享6MB的三级缓存。越接近内存，从其中读取数据所花费的时间越长。下文介绍的侧信道攻击技术正是利用了这一特性。

# 侧信道攻击技术

原文【1】中提到的侧信道攻击技术包括`Flush+Reload`、`Evict+Reload`等，但本文只讨论`Flush+Reload`技术。
`Flush+Reload`技术于2013年提出，是基于内存共享机制和`CPU`多级缓存的侧信道攻击手段。该技术利用`CPU`中的LLC（即L3 Cache），所以并不要求攻击者与受害者在同一核心中执行（以往的针对缓存的侧信道攻击大多要求攻击者与受害者处于同一核心中），只需要它们在同一处理器中执行即可。为了证明`Flush+Reload`的强大功能，原作者做了两组攻击**RSA**的实验：一组是在同一操作系统的不同核心中，另一组是在运行在同一主机的不同的虚拟机中。据报告显示，最坏情况下实验仍分别有95%和90%的正确率。

如前所述，该攻击之所以能成功依赖于两点：内存共享机制和多级缓存的管理机制。内存共享在现今的操作系统中主要有以下两点作用：一是可用于进程之间的通信。二是用于减少内存中重复内容的存在，提高内存利用率。内存重复数据删除（memory deduplication）是现有操作系统中一种内存管理机制。该机制会主动的扫描已使用内存，识别并合并具有相同内容的不相关页面。`Flush+Reload`技术利用了这一点，通过将受害者的可执行文件映射到自身的虚拟内存空间中，由于内存重复数据删除，所以在内存中只会存在一份。并且在缓存中也只有一份备份。**Intel**处理器有一个特性是包容式缓存：LLC包含存储在低层级缓存的所有内容的副本，当从LLC中清除掉某一数据时，也会清除掉低级缓存中对应的内容。

基于以上两种机制，便可以实现`Flush+Reload`。首先，攻击者通过将受害者的可执行文件映射到自己的虚拟内存空间，由于内存重复数据删除这一机制，攻击者和受害者在内存中共享同一物理页面，在LLC中的也只有一份备份。随后攻击者将想要监控的内容驱逐出缓存，然后等待受害者执行，在一段时间后，攻击者再次访问监控的内容，通过判断访问时间便可以判断出在这段时间里受害者是否访问过这一内容，由此来泄漏受害者的信息。

![][4]

上图中的代码是原作者在攻击**RSA**时用来探测受害者是否访问特定地址的实现。函数接收一个地址（adrs）放入**ecx**中，第5、6、8、11行的指令用来串行化指令流（确保在执行随后的指令前，之前的指令已经全部执行完成）。`rdtsc`指令用来测定访问**adrs**所花费的时间，该指令会读取`tsc`寄存器的值，低32位放入**eax**，高32位放入**edx**，在这里我们只需要取低32位即可。第10行用来读取**adrs**。13行将用新取得的时间减去之前的时间，得到访问**adrs**的时间，并放入**eax**（time），最后判断读取时间是否小于预设值，如果小于则可以认为受害者在该短时间内访问了该监控内容。之所以可以这样认为在于如果受害者访问了该内容，则该内容将会被加载入缓存，因为同一处理器共用LLC，所以在随后攻击者访问该内容时由于其已经载入缓存，所以花费的时间会比较短。如果受害则和没有访问该内容，则攻击者访问时需从内存中载入该内容，这会消耗较长时间。因此通过对访问时间的长短的测量就可以判断出受害者是否访问过该内容。

了解了以上内容便足够我们理解`Spectre`攻击中涉及到的`Flush+Reload`技术的利用，关于该技术更多的内容可以取阅读参考资料【4】、【5】。

# Spectre攻击

Google研究团队给出的报告【2】中介绍了如下的背景知识：

[Intel优化参考手册](https://www.intel.com/content/dam/www/public/us/en/documents/manuals/64-ia-32-architectures-optimization-manual.pdf)在第2.3.2.3节提到了关于分支预测的如下内容：

> 分支预测能够预测分支的目标，并使处理器在知道真正的分支目标之前就开始执行指令。

第2.3.5.2节关于`L1 Cache`的内容：

> 载入可以发生在：
> [...]
>> * 在前面的分支执行完成之前推测性的执行
>> * 采用乱序和异步的方法处理Cache未命中

现代处理器在处理分支时利用分支预测和推测执行来提高执行效率。如果一个条件分支指令的结果依赖于正在读取的内存值，由于内存速度的缓慢，在读取该内存值的这段时间里，`CPU`并不会一直等待，而是会建立一个包含当前寄存器状态的检查点，随后推测性的选择一个分支执行。当内存值到达后，`CPU`会判断推测是否正确，如果正确，则不再需要该检查点，`CPU`会完成推测指令的执行；如果错误，`CPU`会重新加载检查点，丢弃检查点之后所有指令的执行结果，沿着正确的分支继续执行。

可以看出推测执行可能导致以不正确的方式执行程序，然而处理器被设计为可以恢复这些不正确的执行结果从而保证程序的正确性，所以之前并不认为这种方式存在安全影响。

`spectre`攻击的出现打破了这一局面。虽然说`CPU`可以恢复执行状态到检查点，但是因为推测执行导致的缓存状态的变化，却已经无法恢复。攻击者通过巧妙的构造恶意分支语句，之后通过检测缓存内容的变化，就有机会判断出受害者内存中的值。

考虑如下代码：

![][5]

`untrusted_offset_from_caller`是由调用者控制的数据。**if**语句用于判断`untrusted_offset_from_caller`是否合法，用来确保对`arr1->data`的访问是有效的。因为`untrusted_offset_from_caller`越界，所以**if**分支中的语句并不会被执行。但是如果`arr2->data[200]`、`arr2->data[300]`和`arr1->length`都没有被缓存，其他数据已经存在于缓存中。因为读取`arr1->length`需要花费时间，所以在接下来处理分支语句时处理器会推测性的执行接下来的指令（依靠之前执行分支时的结果来判断该分支的目的），如果执行分支中的指令，由于`untrusted_offset_from_caller`越界，所以我们可以访问到本来不能访问到的内容，并将该值存放到`value`中，`value`的值会影响`index2`，进而影响对`arr2->data`的访问，随后通过侧信道攻击计算出读取`arr2->data[200]`或`arr2->data[300]`的时间就可以判断出`arr1->data[untrusted_offset_from_caller]&1`的结果。

可以看到，Spectre攻击利用处理器处理分支语句时分支预测和推测执行存在的缺陷，诱导受害者推测性地执行在正常情况下不会执行的操作，将受害者的机密信息加载到`CPU`缓存中，随后通过侧信道攻击将该内容泄漏给攻击者。

接下来简单分析一下POC的实现（POC摘自原文附录A）

![][6]

程序定义了`malicious_x`指向攻击者感兴趣的地址，`len`决定了读出内容的长度。随后调用`readMemoryByte`函数读出`malicious_x`指向地址的一个字节。`value`和`score`是两个传出参数，`value[0]`用于保存预测的最优解，`value[1]`保存次优解。`score`的值是对应`value`值可信度的凭证。

![][7]

程序首先使用`_mm_clflush`函数将`array2`数组和`array1_size`清除出缓存，并用`for (volatile int z = 0; z < 100; z++) {}`来确保在调用`victim_function`函数前清除操作已经全部完成。随后进入循环，在每次使用`malicious_x`调用`victim_function`前都会有5次`training_x`（合法值）调用，用以训练分支预测器。

![][8]

`victim_function`函数是将攻击者感兴趣的内容加载入缓存的关键代码。方法与前面泄漏`arr1->data[untrusted_offset_from_caller]&1`的方式相通。其中`x`是攻击者可控的数据，`if`语句判断`x`是否合法。在攻击者使用恶意的`x`（`x`指向`array1`外的攻击者感兴趣的地址）调用该函数前，首先多次使用正确的`x`调用该函数，导致分支预测器预测接下来的`if`语句仍很可能为真。而且`array1_size`此时不在缓存中，于是在加载`array1_size`的这段时间里，`CPU`预测分支语句为真，使用恶意的`x`执行`array2[array1[x] * 512]`，该语句将根据`array1[x]`（攻击者感兴趣的内容）的值将把`array2`对应位置内容加载入缓存。随后`CPU`意识到推测执行错误，但是此时缓存的状态已经无法恢复。

![][9]

此时攻击者感兴趣的值已经被加载入缓存中，接下来程序遍历`array2[mix_i * 512]`（0<=mix_i<=255，并且mix_i做了一个变换，打乱了顺序），使用`__rdtscp`[6]记录下读取该值所花费的时间， 如果该值小于`CACHE_HIT_THRESHOLD`，并且`mix_i != array1[training_x]`的话就认为该值在缓存中（`victim_function`访问了该值），将该值的访问次数加一

![][10]

这里取出到该轮循环为止的最优解和次优解分别放于j、k，并且判断结果是否满足预先设定的条件，如果满足，则认为已经找到最优解，跳出循环。否则进行下一次尝试。

![][11]

在`readMemoryByte`函数的末尾将得到的结果放入`value`和`score`，返回main函数。在main函数中打印出此次预测的结果，然会继续读取下一个字节，直到达到设定的读取长度`len`。

# 一些不足

1. 分支预测器的预测分支结果的方法还不了解，需要之后在花时间研究
2. 很多文章中提到`Spectre`漏洞可用于泄漏其他可执行程序的内容，但是就给出的**POC**来看，泄漏内存时使用的时虚拟地址空间中的地址，所以没有办法泄漏其他可执行程序的内容，这一点还不理解

# 参考资料

1. [Spectre Attacks: Exploiting Speculative Execution](https://spectreattack.com/spectre.pdf)
2. [Reading privileged memory with a side-channel](https://googleprojectzero.blogspot.co.il/2018/01/reading-privileged-memory-with-side.html)
3. [关于CPU Cache -- 程序猿需要知道的那些事](http://cenalulu.github.io/linux/all-about-cpu-cache/)
4. [FLUSH+RELOAD: a High Resolution, Low Noise,
L3 Cache Side-Channel Attack](https://eprint.iacr.org/2013/448.pdf)
5. [Side-Channel Attacks on Everyday Applications](https://github.com/defuse/flush-reload-attacks)

[1]: https://wx1.sinaimg.cn/large/ee2fecafgy1fnpf2xd9frj20p00dwaai.jpg
[2]: https://wx4.sinaimg.cn/large/ee2fecafgy1fnpf2wwuyvj20pc0gkwii.jpg
[3]: https://wx1.sinaimg.cn/large/ee2fecafgy1fnpf2z6py8j20ds07bweq.jpg
[4]: https://wx4.sinaimg.cn/large/ee2fecafgy1fnpf2y6ainj20ct0ah74s.jpg
[5]: https://wx3.sinaimg.cn/large/ee2fecafgy1fnpf329q09j20g708oaa8.jpg
[6]: https://wx3.sinaimg.cn/large/ee2fecafgy1fnpf2ynn48j20n50cq76p.jpg
[7]: https://wx3.sinaimg.cn/large/ee2fecafgy1fnpf2zveoij20mk0fo0v5.jpg
[8]: https://wx4.sinaimg.cn/large/ee2fecafgy1fnpf30lz32j20k203swer.jpg
[9]: https://wx4.sinaimg.cn/large/ee2fecafgy1fnpf3147c2j20m6056aaz.jpg
[10]: https://wx4.sinaimg.cn/large/ee2fecafgy1fnpf31inl9j20me06fdge.jpg
[11]: https://wx2.sinaimg.cn/large/ee2fecafgy1fnpf31vnwij20jw02gaab.jpg
